// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
)

const addProductToOrganisation = `-- name: AddProductToOrganisation :exec
INSERT INTO product_organisations (product_id,
                                   organisation_id)
VALUES (?,
        ?)
`

type AddProductToOrganisationParams struct {
	ProductID      sql.NullInt64
	OrganisationID sql.NullInt64
}

func (q *Queries) AddProductToOrganisation(ctx context.Context, arg AddProductToOrganisationParams) error {
	_, err := q.db.ExecContext(ctx, addProductToOrganisation, arg.ProductID, arg.OrganisationID)
	return err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (name,
                      tags,
                      description,
                      created_at,
                      updated_at)
VALUES (?,
        ?,
        ?,
        CAST(strftime('%s', 'now') AS INTEGER),
        CAST(strftime('%s', 'now') AS INTEGER))
RETURNING id, name, description, tags, created_at, updated_at
`

type CreateProductParams struct {
	Name        string
	Tags        sql.NullString
	Description string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct, arg.Name, arg.Tags, arg.Description)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPullRequest = `-- name: CreatePullRequest :one
INSERT INTO pull_requests (external_id,
                           title,
                           repository_name,
                           url,
                           state,
                           author,
                           merged_at,
                           created_at,
                           updated_at)
VALUES (?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        CAST(strftime('%s', 'now') AS INTEGER))
ON CONFLICT (external_id) DO UPDATE SET title           = excluded.title,
                                        repository_name = excluded.repository_name,
                                        url             = excluded.url,
                                        state           = excluded.state,
                                        author          = excluded.author,
                                        merged_at       = excluded.merged_at,
                                        updated_at      = CAST(strftime('%s', 'now') AS INTEGER)
RETURNING id, external_id, title, repository_name, url, state, author, merged_at, created_at, updated_at
`

type CreatePullRequestParams struct {
	ExternalID     string
	Title          string
	RepositoryName string
	Url            string
	State          string
	Author         string
	MergedAt       sql.NullInt64
	CreatedAt      int64
}

func (q *Queries) CreatePullRequest(ctx context.Context, arg CreatePullRequestParams) (PullRequest, error) {
	row := q.db.QueryRowContext(ctx, createPullRequest,
		arg.ExternalID,
		arg.Title,
		arg.RepositoryName,
		arg.Url,
		arg.State,
		arg.Author,
		arg.MergedAt,
		arg.CreatedAt,
	)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Title,
		&i.RepositoryName,
		&i.Url,
		&i.State,
		&i.Author,
		&i.MergedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRepo = `-- name: CreateRepo :one
INSERT INTO repositories (name,
                          url,
                          topic,
                          owner,
                          created_at,
                          updated_at)
VALUES (?,
        ?,
        ?,
        ?,
        CAST(strftime('%s', 'now') AS INTEGER),
        CAST(strftime('%s', 'now') AS INTEGER))
RETURNING id, name, url, topic, owner, created_at, updated_at
`

type CreateRepoParams struct {
	Name  string
	Url   string
	Topic string
	Owner string
}

func (q *Queries) CreateRepo(ctx context.Context, arg CreateRepoParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, createRepo,
		arg.Name,
		arg.Url,
		arg.Topic,
		arg.Owner,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Topic,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSecurity = `-- name: CreateSecurity :one
INSERT INTO securities (external_id,
                        repository_name,
                        package_name,
                        state, severity,
                        patched_version,
                        fixed_at,
                        created_at,
                        updated_at)
VALUES (?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        CAST(strftime('%s', 'now') AS INTEGER))
ON CONFLICT (external_id) DO UPDATE SET repository_name = excluded.repository_name,
                                        package_name    = excluded.package_name,
                                        state           = excluded.state,
                                        severity        = excluded.severity,
                                        patched_version = excluded.patched_version,
                                        fixed_at        = excluded.fixed_at,
                                        updated_at      = CAST(strftime('%s', 'now') AS INTEGER)
RETURNING id, external_id, repository_name, package_name, state, severity, patched_version, fixed_at, created_at, updated_at
`

type CreateSecurityParams struct {
	ExternalID     string
	RepositoryName string
	PackageName    string
	State          string
	Severity       string
	PatchedVersion string
	FixedAt        sql.NullInt64
	CreatedAt      int64
}

func (q *Queries) CreateSecurity(ctx context.Context, arg CreateSecurityParams) (Security, error) {
	row := q.db.QueryRowContext(ctx, createSecurity,
		arg.ExternalID,
		arg.RepositoryName,
		arg.PackageName,
		arg.State,
		arg.Severity,
		arg.PatchedVersion,
		arg.FixedAt,
		arg.CreatedAt,
	)
	var i Security
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.RepositoryName,
		&i.PackageName,
		&i.State,
		&i.Severity,
		&i.PatchedVersion,
		&i.FixedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE
FROM products
where id = ?
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const deleteProductOrganisationByOrgID = `-- name: DeleteProductOrganisationByOrgID :exec
DELETE
FROM product_organisations
WHERE organisation_id = ?
`

func (q *Queries) DeleteProductOrganisationByOrgID(ctx context.Context, organisationID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteProductOrganisationByOrgID, organisationID)
	return err
}

const deletePullRequestsByProductID = `-- name: DeletePullRequestsByProductID :exec
DELETE
FROM pull_requests
WHERE external_id IN (SELECT pr.external_id
                      FROM pull_requests pr
                               JOIN repositories r ON r.name = pr.repository_name
                               JOIN products p ON p.id = ?
                          AND JSON_VALID(p.tags)
                          AND EXISTS (SELECT 1
                                      FROM JSON_EACH(p.tags)
                                      WHERE JSON_EACH.value = r.topic))
`

func (q *Queries) DeletePullRequestsByProductID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePullRequestsByProductID, id)
	return err
}

const deleteReposByProductID = `-- name: DeleteReposByProductID :exec
DELETE
FROM repositories
WHERE topic IN (SELECT JSON_EACH.value
                FROM products p, JSON_EACH(p.tags)
                WHERE p.id = ?
                  AND JSON_VALID(p.tags))
`

func (q *Queries) DeleteReposByProductID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteReposByProductID, id)
	return err
}

const deleteSecurityByProductID = `-- name: DeleteSecurityByProductID :exec
DELETE
FROM securities
WHERE external_id IN (SELECT s.external_id
                      FROM securities s
                               JOIN repositories r ON r.name = s.repository_name
                               JOIN products p ON p.id = ?
                          AND JSON_VALID(p.tags)
                          AND EXISTS (SELECT 1
                                      FROM JSON_EACH(p.tags)
                                      WHERE JSON_EACH.value = r.topic))
`

func (q *Queries) DeleteSecurityByProductID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSecurityByProductID, id)
	return err
}

const getOrganisationForProduct = `-- name: GetOrganisationForProduct :one
SELECT o.id, o.friendly_name, o.description, o.namespace, o.default_org, o.token, o.created_at, o.updated_at
FROM product_organisations po
         JOIN organisations o ON o.id = po.organisation_id
WHERE po.product_id = ?
LIMIT 1
`

func (q *Queries) GetOrganisationForProduct(ctx context.Context, productID sql.NullInt64) (Organisation, error) {
	row := q.db.QueryRowContext(ctx, getOrganisationForProduct, productID)
	var i Organisation
	err := row.Scan(
		&i.ID,
		&i.FriendlyName,
		&i.Description,
		&i.Namespace,
		&i.DefaultOrg,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, name, description, tags, created_at, updated_at
FROM products
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetProductByID(ctx context.Context, id int64) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPullRequestByProductIDAndState = `-- name: GetPullRequestByProductIDAndState :many
SELECT pr.id, pr.external_id, pr.title, pr.repository_name, pr.url, pr.state, pr.author, pr.merged_at, pr.created_at, pr.updated_at, r.topic as tag, p.name as product_name
FROM pull_requests pr
         JOIN repositories r ON r.name = pr.repository_name
         JOIN products p ON p.id = ?
    AND JSON_VALID(p.tags)
    AND EXISTS (SELECT 1
                FROM JSON_EACH(p.tags)
                WHERE JSON_EACH.value = r.topic)
WHERE pr.state = ?
ORDER BY pr.created_at DESC
`

type GetPullRequestByProductIDAndStateParams struct {
	ID    int64
	State string
}

type GetPullRequestByProductIDAndStateRow struct {
	ID             int64
	ExternalID     string
	Title          string
	RepositoryName string
	Url            string
	State          string
	Author         string
	MergedAt       sql.NullInt64
	CreatedAt      int64
	UpdatedAt      int64
	Tag            string
	ProductName    string
}

func (q *Queries) GetPullRequestByProductIDAndState(ctx context.Context, arg GetPullRequestByProductIDAndStateParams) ([]GetPullRequestByProductIDAndStateRow, error) {
	rows, err := q.db.QueryContext(ctx, getPullRequestByProductIDAndState, arg.ID, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPullRequestByProductIDAndStateRow
	for rows.Next() {
		var i GetPullRequestByProductIDAndStateRow
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Title,
			&i.RepositoryName,
			&i.Url,
			&i.State,
			&i.Author,
			&i.MergedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tag,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPullRequestsByOrganisationAndState = `-- name: GetPullRequestsByOrganisationAndState :many
SELECT pr.id, pr.external_id, pr.title, pr.repository_name, pr.url, pr.state, pr.author, pr.merged_at, pr.created_at, pr.updated_at, r.topic as tag, p.name as product_name
FROM pull_requests pr
         JOIN repositories r ON r.name = pr.repository_name
         JOIN product_organisations po
         JOIN products p ON p.id = po.product_id
    AND JSON_VALID(p.tags)
    AND EXISTS (SELECT 1
                FROM JSON_EACH(p.tags)
                WHERE JSON_EACH.value = r.topic)
WHERE po.organisation_id = ?
  AND pr.state = ?
ORDER BY pr.created_at DESC
`

type GetPullRequestsByOrganisationAndStateParams struct {
	OrganisationID sql.NullInt64
	State          string
}

type GetPullRequestsByOrganisationAndStateRow struct {
	ID             int64
	ExternalID     string
	Title          string
	RepositoryName string
	Url            string
	State          string
	Author         string
	MergedAt       sql.NullInt64
	CreatedAt      int64
	UpdatedAt      int64
	Tag            string
	ProductName    string
}

func (q *Queries) GetPullRequestsByOrganisationAndState(ctx context.Context, arg GetPullRequestsByOrganisationAndStateParams) ([]GetPullRequestsByOrganisationAndStateRow, error) {
	rows, err := q.db.QueryContext(ctx, getPullRequestsByOrganisationAndState, arg.OrganisationID, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPullRequestsByOrganisationAndStateRow
	for rows.Next() {
		var i GetPullRequestsByOrganisationAndStateRow
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Title,
			&i.RepositoryName,
			&i.Url,
			&i.State,
			&i.Author,
			&i.MergedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tag,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepoByName = `-- name: GetRepoByName :one
SELECT id, name, url, topic, owner, created_at, updated_at
FROM repositories
WHERE name = ?
LIMIT 1
`

func (q *Queries) GetRepoByName(ctx context.Context, name string) (Repository, error) {
	row := q.db.QueryRowContext(ctx, getRepoByName, name)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Topic,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReposByProductID = `-- name: GetReposByProductID :many
SELECT r.id, r.name, r.url, r.topic, r.owner, r.created_at, r.updated_at, p.name as product_name
FROM repositories r
         JOIN products p ON p.id = ?
    AND JSON_VALID(p.tags)
    AND EXISTS (SELECT 1
                FROM JSON_EACH(p.tags)
                WHERE JSON_EACH.value = r.topic)
`

type GetReposByProductIDRow struct {
	ID          int64
	Name        string
	Url         string
	Topic       string
	Owner       string
	CreatedAt   int64
	UpdatedAt   int64
	ProductName string
}

func (q *Queries) GetReposByProductID(ctx context.Context, id int64) ([]GetReposByProductIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getReposByProductID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReposByProductIDRow
	for rows.Next() {
		var i GetReposByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Topic,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityByOrganisationAndState = `-- name: GetSecurityByOrganisationAndState :many
SELECT s.id, s.external_id, s.repository_name, s.package_name, s.state, s.severity, s.patched_version, s.fixed_at, s.created_at, s.updated_at, r.topic as tag, p.name as product_name
FROM securities s
         JOIN repositories r ON r.name = s.repository_name
         JOIN product_organisations po
         JOIN products p ON p.id = po.product_id
    AND JSON_VALID(p.tags)
    AND EXISTS (SELECT 1
                FROM JSON_EACH(p.tags)
                WHERE JSON_EACH.value = r.topic)
WHERE po.organisation_id = ?
  AND s.state = ?
ORDER BY s.created_at DESC
`

type GetSecurityByOrganisationAndStateParams struct {
	OrganisationID sql.NullInt64
	State          string
}

type GetSecurityByOrganisationAndStateRow struct {
	ID             int64
	ExternalID     string
	RepositoryName string
	PackageName    string
	State          string
	Severity       string
	PatchedVersion string
	FixedAt        sql.NullInt64
	CreatedAt      int64
	UpdatedAt      int64
	Tag            string
	ProductName    string
}

func (q *Queries) GetSecurityByOrganisationAndState(ctx context.Context, arg GetSecurityByOrganisationAndStateParams) ([]GetSecurityByOrganisationAndStateRow, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityByOrganisationAndState, arg.OrganisationID, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSecurityByOrganisationAndStateRow
	for rows.Next() {
		var i GetSecurityByOrganisationAndStateRow
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.RepositoryName,
			&i.PackageName,
			&i.State,
			&i.Severity,
			&i.PatchedVersion,
			&i.FixedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tag,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityByProductIDAndState = `-- name: GetSecurityByProductIDAndState :many
SELECT s.id, s.external_id, s.repository_name, s.package_name, s.state, s.severity, s.patched_version, s.fixed_at, s.created_at, s.updated_at, r.topic as tag, p.name as product_name
FROM securities s
         JOIN repositories r ON r.name = s.repository_name
         JOIN products p ON p.id = ?
    AND JSON_VALID(p.tags)
    AND EXISTS (SELECT 1
                FROM JSON_EACH(p.tags)
                WHERE JSON_EACH.value = r.topic)
WHERE s.state = ?
ORDER BY s.created_at DESC
`

type GetSecurityByProductIDAndStateParams struct {
	ID    int64
	State string
}

type GetSecurityByProductIDAndStateRow struct {
	ID             int64
	ExternalID     string
	RepositoryName string
	PackageName    string
	State          string
	Severity       string
	PatchedVersion string
	FixedAt        sql.NullInt64
	CreatedAt      int64
	UpdatedAt      int64
	Tag            string
	ProductName    string
}

func (q *Queries) GetSecurityByProductIDAndState(ctx context.Context, arg GetSecurityByProductIDAndStateParams) ([]GetSecurityByProductIDAndStateRow, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityByProductIDAndState, arg.ID, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSecurityByProductIDAndStateRow
	for rows.Next() {
		var i GetSecurityByProductIDAndStateRow
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.RepositoryName,
			&i.PackageName,
			&i.State,
			&i.Severity,
			&i.PatchedVersion,
			&i.FixedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tag,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByOrganisation = `-- name: ListProductsByOrganisation :many
SELECT p.id, p.name, p.description, p.tags, p.created_at, p.updated_at
FROM products p
         JOIN product_organisations po ON po.product_id = p.id
WHERE po.organisation_id = ?
ORDER BY p.name
`

func (q *Queries) ListProductsByOrganisation(ctx context.Context, organisationID sql.NullInt64) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByOrganisation, organisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET name        = ?,
    tags        = ?,
    description = ?,
    updated_at  = CAST(strftime('%s', 'now') AS INTEGER)
WHERE id = ?
RETURNING id, name, description, tags, created_at, updated_at
`

type UpdateProductParams struct {
	Name        string
	Tags        sql.NullString
	Description string
	ID          int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.Name,
		arg.Tags,
		arg.Description,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductSync = `-- name: UpdateProductSync :exec
UPDATE products
SET updated_at = CAST(strftime('%s', 'now') AS INTEGER)
WHERE id = ?
`

func (q *Queries) UpdateProductSync(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateProductSync, id)
	return err
}

const updateRepo = `-- name: UpdateRepo :one
UPDATE repositories
SET name       = ?,
    url        = ?,
    topic      = ?,
    owner      = ?,
    updated_at = CAST(strftime('%s', 'now') AS INTEGER)
WHERE id = ?
RETURNING id, name, url, topic, owner, created_at, updated_at
`

type UpdateRepoParams struct {
	Name  string
	Url   string
	Topic string
	Owner string
	ID    int64
}

func (q *Queries) UpdateRepo(ctx context.Context, arg UpdateRepoParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, updateRepo,
		arg.Name,
		arg.Url,
		arg.Topic,
		arg.Owner,
		arg.ID,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Topic,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
