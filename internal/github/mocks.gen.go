// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package github

import (
	"io"
	"net/http"
	"sync"
)

// Ensure, that fetcherMock does implement fetcher.
// If this is not the case, regenerate this file with moq.
var _ fetcher = &fetcherMock{}

// fetcherMock is a mock implementation of fetcher.
//
//	func TestSomethingThatUsesfetcher(t *testing.T) {
//
//		// make and configure a mocked fetcher
//		mockedfetcher := &fetcherMock{
//			PostFunc: func(url string, body io.Reader, headers map[string]string) (*http.Response, error) {
//				panic("mock out the Post method")
//			},
//		}
//
//		// use mockedfetcher in code that requires fetcher
//		// and then make assertions.
//
//	}
type fetcherMock struct {
	// PostFunc mocks the Post method.
	PostFunc func(url string, body io.Reader, headers map[string]string) (*http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Post holds details about calls to the Post method.
		Post []struct {
			// URL is the url argument value.
			URL string
			// Body is the body argument value.
			Body io.Reader
			// Headers is the headers argument value.
			Headers map[string]string
		}
	}
	lockPost sync.RWMutex
}

// Post calls PostFunc.
func (mock *fetcherMock) Post(url string, body io.Reader, headers map[string]string) (*http.Response, error) {
	callInfo := struct {
		URL     string
		Body    io.Reader
		Headers map[string]string
	}{
		URL:     url,
		Body:    body,
		Headers: headers,
	}
	mock.lockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	mock.lockPost.Unlock()
	if mock.PostFunc == nil {
		var (
			responseOut *http.Response
			errOut      error
		)
		return responseOut, errOut
	}
	return mock.PostFunc(url, body, headers)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//
//	len(mockedfetcher.PostCalls())
func (mock *fetcherMock) PostCalls() []struct {
	URL     string
	Body    io.Reader
	Headers map[string]string
} {
	var calls []struct {
		URL     string
		Body    io.Reader
		Headers map[string]string
	}
	mock.lockPost.RLock()
	calls = mock.calls.Post
	mock.lockPost.RUnlock()
	return calls
}

// Ensure, that ClientGithubMock does implement ClientGithub.
// If this is not the case, regenerate this file with moq.
var _ ClientGithub = &ClientGithubMock{}

// ClientGithubMock is a mock implementation of ClientGithub.
//
//	func TestSomethingThatUsesClientGithub(t *testing.T) {
//
//		// make and configure a mocked ClientGithub
//		mockedClientGithub := &ClientGithubMock{
//			GetRepoDetailsFunc: func(owner string, repo string, token string) (QueryRepository, error) {
//				panic("mock out the GetRepoDetails method")
//			},
//			SearchReposFunc: func(owner string, topic string, token string) (QuerySearch[Repository], error) {
//				panic("mock out the SearchRepos method")
//			},
//		}
//
//		// use mockedClientGithub in code that requires ClientGithub
//		// and then make assertions.
//
//	}
type ClientGithubMock struct {
	// GetRepoDetailsFunc mocks the GetRepoDetails method.
	GetRepoDetailsFunc func(owner string, repo string, token string) (QueryRepository, error)

	// SearchReposFunc mocks the SearchRepos method.
	SearchReposFunc func(owner string, topic string, token string) (QuerySearch[Repository], error)

	// calls tracks calls to the methods.
	calls struct {
		// GetRepoDetails holds details about calls to the GetRepoDetails method.
		GetRepoDetails []struct {
			// Owner is the owner argument value.
			Owner string
			// Repo is the repo argument value.
			Repo string
			// Token is the token argument value.
			Token string
		}
		// SearchRepos holds details about calls to the SearchRepos method.
		SearchRepos []struct {
			// Owner is the owner argument value.
			Owner string
			// Topic is the topic argument value.
			Topic string
			// Token is the token argument value.
			Token string
		}
	}
	lockGetRepoDetails sync.RWMutex
	lockSearchRepos    sync.RWMutex
}

// GetRepoDetails calls GetRepoDetailsFunc.
func (mock *ClientGithubMock) GetRepoDetails(owner string, repo string, token string) (QueryRepository, error) {
	callInfo := struct {
		Owner string
		Repo  string
		Token string
	}{
		Owner: owner,
		Repo:  repo,
		Token: token,
	}
	mock.lockGetRepoDetails.Lock()
	mock.calls.GetRepoDetails = append(mock.calls.GetRepoDetails, callInfo)
	mock.lockGetRepoDetails.Unlock()
	if mock.GetRepoDetailsFunc == nil {
		var (
			queryRepositoryOut QueryRepository
			errOut             error
		)
		return queryRepositoryOut, errOut
	}
	return mock.GetRepoDetailsFunc(owner, repo, token)
}

// GetRepoDetailsCalls gets all the calls that were made to GetRepoDetails.
// Check the length with:
//
//	len(mockedClientGithub.GetRepoDetailsCalls())
func (mock *ClientGithubMock) GetRepoDetailsCalls() []struct {
	Owner string
	Repo  string
	Token string
} {
	var calls []struct {
		Owner string
		Repo  string
		Token string
	}
	mock.lockGetRepoDetails.RLock()
	calls = mock.calls.GetRepoDetails
	mock.lockGetRepoDetails.RUnlock()
	return calls
}

// SearchRepos calls SearchReposFunc.
func (mock *ClientGithubMock) SearchRepos(owner string, topic string, token string) (QuerySearch[Repository], error) {
	callInfo := struct {
		Owner string
		Topic string
		Token string
	}{
		Owner: owner,
		Topic: topic,
		Token: token,
	}
	mock.lockSearchRepos.Lock()
	mock.calls.SearchRepos = append(mock.calls.SearchRepos, callInfo)
	mock.lockSearchRepos.Unlock()
	if mock.SearchReposFunc == nil {
		var (
			querySearchOut QuerySearch[Repository]
			errOut         error
		)
		return querySearchOut, errOut
	}
	return mock.SearchReposFunc(owner, topic, token)
}

// SearchReposCalls gets all the calls that were made to SearchRepos.
// Check the length with:
//
//	len(mockedClientGithub.SearchReposCalls())
func (mock *ClientGithubMock) SearchReposCalls() []struct {
	Owner string
	Topic string
	Token string
} {
	var calls []struct {
		Owner string
		Topic string
		Token string
	}
	mock.lockSearchRepos.RLock()
	calls = mock.calls.SearchRepos
	mock.lockSearchRepos.RUnlock()
	return calls
}
